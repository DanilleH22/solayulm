"use client";
import {
  require_react
} from "./chunk-E3WV3ANG.js";
import {
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/react-color-palette/dist/rcp.mjs
var import_react = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var import_react3 = __toESM(require_react(), 1);
var import_react4 = __toESM(require_react(), 1);
var import_react5 = __toESM(require_react(), 1);
var import_react6 = __toESM(require_react(), 1);
var import_react7 = __toESM(require_react(), 1);
var import_react8 = __toESM(require_react(), 1);
function isFieldHide(hideInput, field) {
  return Array.isArray(hideInput) ? hideInput.includes(field) : hideInput;
}
var getElementDimensions = (element) => {
  const rect = element.getBoundingClientRect();
  return {
    width: rect.width,
    height: rect.height
  };
};
function useBoundingClientRect() {
  const ref = (0, import_react3.useRef)(null);
  const [size, setSize] = (0, import_react3.useState)({ width: 1, height: 1 });
  (0, import_react3.useLayoutEffect)(() => {
    const onWindowResize = () => {
      if (!ref.current)
        return;
      setSize(getElementDimensions(ref.current));
    };
    const onElementResize = ([{ contentBoxSize }]) => {
      setSize({
        height: contentBoxSize[0].blockSize,
        width: contentBoxSize[0].inlineSize
      });
    };
    window.addEventListener("resize", onWindowResize, false);
    const observer = new ResizeObserver(onElementResize);
    if (ref.current)
      observer.observe(ref.current);
    return () => {
      window.removeEventListener("resize", onWindowResize, false);
      observer.disconnect();
    };
  }, []);
  const getPosition = (0, import_react3.useCallback)(() => {
    var _a;
    const { left = 1, right = 1, top = 1, bottom = 1 } = ((_a = ref.current) == null ? void 0 : _a.getBoundingClientRect()) ?? {};
    return { left, right, top, bottom };
  }, []);
  return [ref, size, getPosition];
}
function clamp(value, min, max) {
  return value < min ? min : value > max ? max : value;
}
var ColorServiceStatic = class {
  convert(model, color) {
    let hex = this.toHex("#000000");
    let rgb = this.hex2rgb(hex);
    let hsv = this.rgb2hsv(rgb);
    if (model === "hex") {
      const value = color;
      hex = this.toHex(value);
      rgb = this.hex2rgb(hex);
      if (hex.startsWith("rgba")) {
        rgb = this.toRgb(hex);
        hex = this.rgb2hex(rgb);
      }
      hsv = this.rgb2hsv(rgb);
    } else if (model === "rgb") {
      const value = color;
      rgb = value;
      hex = this.rgb2hex(rgb);
      hsv = this.rgb2hsv(rgb);
    } else if (model === "hsv") {
      const value = color;
      hsv = value;
      rgb = this.hsv2rgb(hsv);
      hex = this.rgb2hex(rgb);
    }
    return { hex, rgb, hsv };
  }
  toHex(value) {
    if (!value.startsWith("#")) {
      const ctx = document.createElement("canvas").getContext("2d");
      if (!ctx)
        throw new Error("2d context not supported or canvas already initialized");
      ctx.fillStyle = value;
      return ctx.fillStyle;
    } else if (value.length === 4 || value.length === 5) {
      value = value.split("").map((v, i) => i ? i < 4 ? v + v : v === "f" ? void 0 : v + v : "#").join("");
      return value;
    } else if (value.length === 7) {
      return value;
    } else if (value.length === 9) {
      return value.endsWith("ff") ? value.slice(0, 7) : value;
    }
    return "#000000";
  }
  toRgb(value) {
    const rgb = value.match(/\d+(\.\d+)?/gu) ?? [];
    const [r, g, b, a] = Array.from({ length: 4 }).map(
      (_, i) => clamp(+(rgb[i] ?? (i < 3 ? 0 : 1)), 0, i < 3 ? 255 : 1)
    );
    return { r, g, b, a };
  }
  toHsv(value) {
    const hsv = value.match(/\d+(\.\d+)?/gu) ?? [];
    const [h, s, v, a] = Array.from({ length: 4 }).map(
      (_, i) => clamp(+(hsv[i] ?? (i < 3 ? 0 : 1)), 0, i ? i < 3 ? 100 : 1 : 360)
    );
    return { h, s, v, a };
  }
  hex2rgb(hex) {
    hex = hex.slice(1);
    let [r, g, b, a] = Array.from({ length: 4 }).map((_, i) => parseInt(hex.slice(i * 2, i * 2 + 2), 16));
    a = Number.isNaN(a) ? 1 : a / 255;
    return { r, g, b, a };
  }
  rgb2hsv({ r, g, b, a }) {
    r /= 255;
    g /= 255;
    b /= 255;
    const max = Math.max(r, g, b);
    const d = max - Math.min(r, g, b);
    const h = d ? (max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? 2 + (b - r) / d : 4 + (r - g) / d) * 60 : 0;
    const s = max ? d / max * 100 : 0;
    const v = max * 100;
    return { h, s, v, a };
  }
  hsv2rgb({ h, s, v, a }) {
    s /= 100;
    v /= 100;
    const i = ~~(h / 60);
    const f = h / 60 - i;
    const p = v * (1 - s);
    const q = v * (1 - s * f);
    const t = v * (1 - s * (1 - f));
    const index = i % 6;
    const r = [v, q, p, p, t, v][index] * 255;
    const g = [t, v, v, q, p, p][index] * 255;
    const b = [p, p, t, v, v, q][index] * 255;
    return { r, g, b, a };
  }
  rgb2hex({ r, g, b, a }) {
    const [rr, gg, bb, aa] = [r, g, b, a].map(
      (v, i) => Math.round(i < 3 ? v : v * 255).toString(16).padStart(2, "0")
    );
    return ["#", rr, gg, bb, aa === "ff" ? "" : aa].join("");
  }
};
var ColorService = new ColorServiceStatic();
function isTouch(event) {
  return "touches" in event;
}
var Interactive = (0, import_react4.memo)(({ onCoordinateChange, children, disabled }) => {
  const [interactiveRef, { width, height }, getPosition] = useBoundingClientRect();
  const move = (0, import_react4.useCallback)(
    (event, final = false) => {
      const { left, top } = getPosition();
      const x = clamp(event.clientX - left, 0, width);
      const y = clamp(event.clientY - top, 0, height);
      onCoordinateChange(final, x, y);
    },
    [width, height, getPosition, onCoordinateChange]
  );
  const onStart = (0, import_react4.useCallback)(
    (event) => {
      if (!isTouch(event) && event.button !== 0)
        return;
      const onMove = (event2) => {
        move(isTouch(event2) ? event2.touches[0] : event2);
      };
      const onEnd = (event2) => {
        move(isTouch(event2) ? event2.changedTouches[0] : event2, true);
        document.removeEventListener(isTouch(event2) ? "touchmove" : "mousemove", onMove, false);
        document.removeEventListener(isTouch(event2) ? "touchend" : "mouseup", onEnd, false);
      };
      onMove(event);
      document.addEventListener(isTouch(event) ? "touchmove" : "mousemove", onMove, false);
      document.addEventListener(isTouch(event) ? "touchend" : "mouseup", onEnd, false);
    },
    [move]
  );
  return import_react4.default.createElement(
    "div",
    {
      ref: interactiveRef,
      className: "rcp-interactive",
      onMouseDown: onStart,
      onTouchStart: onStart,
      "aria-disabled": disabled
    },
    children
  );
});
var Alpha = (0, import_react2.memo)(({ color, disabled, onChange, onChangeComplete }) => {
  const [alphaRef, { width }] = useBoundingClientRect();
  const position = (0, import_react2.useMemo)(() => {
    const x = color.hsv.a * width;
    return { x };
  }, [color.hsv.a, width]);
  const updateColor = (0, import_react2.useCallback)(
    (final, x) => {
      const nextColor = ColorService.convert("hsv", {
        ...color.hsv,
        a: x / width
      });
      onChange(nextColor);
      if (final)
        onChangeComplete == null ? void 0 : onChangeComplete(nextColor);
    },
    [color.hsv, width, onChange, onChangeComplete]
  );
  const rgb = (0, import_react2.useMemo)(() => [color.rgb.r, color.rgb.g, color.rgb.b].join(" "), [color.rgb.r, color.rgb.g, color.rgb.b]);
  const rgba = (0, import_react2.useMemo)(() => [rgb, color.rgb.a].join(" / "), [rgb, color.rgb.a]);
  return import_react2.default.createElement(Interactive, { disabled, onCoordinateChange: updateColor }, import_react2.default.createElement(
    "div",
    {
      ref: alphaRef,
      style: {
        background: `linear-gradient(to right, rgb(${rgb} / 0), rgb(${rgb} / 1)) top left / auto auto,
                      conic-gradient(#666 0.25turn, #999 0.25turn 0.5turn, #666 0.5turn 0.75turn, #999 0.75turn) top left / 12px 12px
                      repeat`
      },
      className: "rcp-alpha"
    },
    import_react2.default.createElement(
      "div",
      {
        style: {
          left: position.x,
          background: `linear-gradient(to right, rgb(${rgba}), rgb(${rgba})) top left / auto auto,
                        conic-gradient(#666 0.25turn, #999 0.25turn 0.5turn, #666 0.5turn 0.75turn, #999 0.75turn) ${-position.x - 4}px 2px / 12px 12px
                        repeat`
        },
        className: "rcp-alpha-cursor"
      }
    )
  ));
});
function float(value, decimalPlaces) {
  return Math.round(value * 10 ** decimalPlaces) / 10 ** decimalPlaces;
}
function formatRgb({ r, g, b, a }) {
  const rgb = [Math.round(r), Math.round(g), Math.round(b)];
  const alpha = float(a, 3);
  if (alpha < 1)
    rgb.push(alpha);
  return rgb.join(", ");
}
function formatHsv({ h, s, v, a }) {
  const hsv = [`${Math.round(h)}Â°`, `${Math.round(s)}%`, `${Math.round(v)}%`];
  const alpha = float(a, 3);
  if (alpha < 1)
    hsv.push(alpha);
  return hsv.join(", ");
}
var Fields = (0, import_react5.memo)(({ hideInput, color, disabled, onChange, onChangeComplete }) => {
  const [fields, setFields] = (0, import_react5.useState)({
    hex: {
      value: color.hex,
      inputted: false
    },
    rgb: {
      value: formatRgb(color.rgb),
      inputted: false
    },
    hsv: {
      value: formatHsv(color.hsv),
      inputted: false
    }
  });
  (0, import_react5.useEffect)(() => {
    if (!fields.hex.inputted) {
      setFields((fields2) => ({ ...fields2, hex: { ...fields2.hex, value: color.hex } }));
    }
  }, [fields.hex.inputted, color.hex]);
  (0, import_react5.useEffect)(() => {
    if (!fields.rgb.inputted) {
      setFields((fields2) => ({ ...fields2, rgb: { ...fields2.rgb, value: formatRgb(color.rgb) } }));
    }
  }, [fields.rgb.inputted, color.rgb]);
  (0, import_react5.useEffect)(() => {
    if (!fields.hsv.inputted) {
      setFields((fields2) => ({ ...fields2, hsv: { ...fields2.hsv, value: formatHsv(color.hsv) } }));
    }
  }, [fields.hsv.inputted, color.hsv]);
  const onInputChange = (0, import_react5.useCallback)(
    (field) => (event) => {
      const { value } = event.target;
      setFields((fields2) => ({ ...fields2, [field]: { ...fields2[field], value } }));
      if (field === "hsv")
        onChange(ColorService.convert("hsv", ColorService.toHsv(value)));
      else if (field === "rgb")
        onChange(ColorService.convert("rgb", ColorService.toRgb(value)));
      else
        onChange(ColorService.convert("hex", value));
    },
    [onChange]
  );
  const onInputFocus = (0, import_react5.useCallback)(
    (field) => () => {
      setFields((fields2) => ({ ...fields2, [field]: { ...fields2[field], inputted: true } }));
    },
    []
  );
  const onInputBlur = (0, import_react5.useCallback)(
    (field) => (event) => {
      const { value } = event.target;
      setFields((fields2) => ({ ...fields2, [field]: { ...fields2[field], inputted: false } }));
      if (field === "hsv")
        onChangeComplete == null ? void 0 : onChangeComplete(ColorService.convert("hsv", ColorService.toHsv(value)));
      else if (field === "rgb")
        onChangeComplete == null ? void 0 : onChangeComplete(ColorService.convert("rgb", ColorService.toRgb(value)));
      else
        onChangeComplete == null ? void 0 : onChangeComplete(ColorService.convert("hex", value));
    },
    [onChangeComplete]
  );
  return import_react5.default.createElement("div", { className: "rcp-fields" }, !isFieldHide(hideInput, "hex") && import_react5.default.createElement("div", { className: "rcp-fields-floor" }, import_react5.default.createElement("div", { className: "rcp-field" }, import_react5.default.createElement(
    "input",
    {
      id: "hex",
      className: "rcp-field-input",
      readOnly: disabled,
      value: fields.hex.value,
      onChange: onInputChange("hex"),
      onFocus: onInputFocus("hex"),
      onBlur: onInputBlur("hex")
    }
  ), import_react5.default.createElement("label", { htmlFor: "hex", className: "rcp-field-label" }, "HEX"))), (!isFieldHide(hideInput, "rgb") || !isFieldHide(hideInput, "hsv")) && import_react5.default.createElement("div", { className: "rcp-fields-floor" }, !isFieldHide(hideInput, "rgb") && import_react5.default.createElement("div", { className: "rcp-field" }, import_react5.default.createElement(
    "input",
    {
      id: "rgb",
      className: "rcp-field-input",
      readOnly: disabled,
      value: fields.rgb.value,
      onChange: onInputChange("rgb"),
      onFocus: onInputFocus("rgb"),
      onBlur: onInputBlur("rgb")
    }
  ), import_react5.default.createElement("label", { htmlFor: "rgb", className: "rcp-field-label" }, "RGB")), !isFieldHide(hideInput, "hsv") && import_react5.default.createElement("div", { className: "rcp-field" }, import_react5.default.createElement(
    "input",
    {
      id: "hsv",
      className: "rcp-field-input",
      readOnly: disabled,
      value: fields.hsv.value,
      onChange: onInputChange("hsv"),
      onFocus: onInputFocus("hsv"),
      onBlur: onInputBlur("hsv")
    }
  ), import_react5.default.createElement("label", { htmlFor: "hsv", className: "rcp-field-label" }, "HSV"))));
});
var Hue = (0, import_react6.memo)(({ color, disabled, onChange, onChangeComplete }) => {
  const [hueRef, { width }] = useBoundingClientRect();
  const position = (0, import_react6.useMemo)(() => {
    const x = color.hsv.h / 360 * width;
    return { x };
  }, [color.hsv.h, width]);
  const updateColor = (0, import_react6.useCallback)(
    (final, x) => {
      const nextColor = ColorService.convert("hsv", {
        ...color.hsv,
        h: x / width * 360
      });
      onChange(nextColor);
      if (final)
        onChangeComplete == null ? void 0 : onChangeComplete(nextColor);
    },
    [color.hsv, width, onChange, onChangeComplete]
  );
  const hsl = (0, import_react6.useMemo)(() => [color.hsv.h, "100%", "50%"].join(" "), [color.hsv.h]);
  return import_react6.default.createElement(Interactive, { disabled, onCoordinateChange: updateColor }, import_react6.default.createElement("div", { ref: hueRef, className: "rcp-hue" }, import_react6.default.createElement("div", { style: { left: position.x, backgroundColor: `hsl(${hsl})` }, className: "rcp-hue-cursor" })));
});
var Saturation = (0, import_react7.memo)(({ height, color, disabled, onChange, onChangeComplete }) => {
  const [saturationRef, { width }] = useBoundingClientRect();
  const position = (0, import_react7.useMemo)(() => {
    const x = color.hsv.s / 100 * width;
    const y = (100 - color.hsv.v) / 100 * height;
    return { x, y };
  }, [color.hsv.s, color.hsv.v, width, height]);
  const updateColor = (0, import_react7.useCallback)(
    (final, x, y) => {
      const nextColor = ColorService.convert("hsv", {
        ...color.hsv,
        s: x / width * 100,
        v: 100 - y / height * 100
      });
      onChange(nextColor);
      if (final)
        onChangeComplete == null ? void 0 : onChangeComplete(nextColor);
    },
    [color.hsv, width, height, onChange, onChangeComplete]
  );
  const hsl = (0, import_react7.useMemo)(() => [color.hsv.h, "100%", "50%"].join(" "), [color.hsv.h]);
  const rgb = (0, import_react7.useMemo)(() => [color.rgb.r, color.rgb.g, color.rgb.b].join(" "), [color.rgb.r, color.rgb.g, color.rgb.b]);
  return import_react7.default.createElement(Interactive, { disabled, onCoordinateChange: updateColor }, import_react7.default.createElement("div", { ref: saturationRef, style: { height, backgroundColor: `hsl(${hsl})` }, className: "rcp-saturation" }, import_react7.default.createElement(
    "div",
    {
      style: { left: position.x, top: position.y, backgroundColor: `rgb(${rgb})` },
      className: "rcp-saturation-cursor"
    }
  )));
});
var ColorPicker = (0, import_react.memo)(
  ({
    height = 200,
    hideAlpha = false,
    hideInput = false,
    color,
    disabled = false,
    onChange,
    onChangeComplete
  }) => import_react.default.createElement("div", { className: "rcp-root rcp" }, import_react.default.createElement(
    Saturation,
    {
      height,
      color,
      disabled,
      onChange,
      onChangeComplete
    }
  ), import_react.default.createElement("div", { className: "rcp-body" }, import_react.default.createElement("section", { className: "rcp-section" }, import_react.default.createElement(Hue, { color, disabled, onChange, onChangeComplete }), !hideAlpha && import_react.default.createElement(Alpha, { color, disabled, onChange, onChangeComplete })), (!isFieldHide(hideInput, "hex") || !isFieldHide(hideInput, "rgb") || !isFieldHide(hideInput, "hsv")) && import_react.default.createElement("section", { className: "rcp-section" }, import_react.default.createElement(
    Fields,
    {
      hideInput,
      color,
      disabled,
      onChange,
      onChangeComplete
    }
  ))))
);
function useColor(initialColor) {
  const [color, setColor] = (0, import_react8.useState)(ColorService.convert("hex", initialColor));
  (0, import_react8.useEffect)(() => {
    setColor(ColorService.convert("hex", initialColor));
  }, [initialColor]);
  return [color, setColor];
}
export {
  Alpha,
  ColorPicker,
  ColorService,
  Hue,
  Saturation,
  useColor
};
//# sourceMappingURL=react-color-palette.js.map
